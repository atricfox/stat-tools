# Contentæ–‡ä»¶å¤¹JSONæ•°æ®è¿ç§»è¯¦ç»†å®æ–½è®¡åˆ’

## ğŸ“‹ è¿ç§»æ¦‚è§ˆ

### ç›®æ ‡æ•°æ®æº
- **FAQæ•°æ®**: `content/faq/statistics-faq.json` (4ä¸ªFAQé¡¹)
- **How-toæ•°æ®**: `content/howto/` (4ä¸ªæŒ‡å—)
  - `calculate-gpa.json`
  - `calculate-mean-step-by-step.json`
  - `calculate-median.json`
  - `calculate-standard-deviation.json`
- **Caseæ•°æ®**: `content/cases/improving-gpa-strategy.json` (1ä¸ªæ¡ˆä¾‹)

### è¿ç§»å¤æ‚åº¦è¯„ä¼°
- **æ•°æ®æ€»é‡**: 9ä¸ªå†…å®¹é¡¹ + ä¸°å¯Œçš„å…ƒæ•°æ®å’Œå…³ç³»æ•°æ®
- **å†…å®¹ç±»å‹**: 3ç§ä¸åŒçš„æ•°æ®ç»“æ„ (FAQæ•°ç»„/How-toå¯¹è±¡/Caseå¯¹è±¡)
- **å…³ç³»å¤æ‚åº¦**: å·¥å…·å…³è”ã€æœ¯è¯­å…³è”ã€å†…å®¹é—´å…³ç³»
- **é¢„è®¡å·¥æ—¶**: 5å¤©å®Œæˆå®Œæ•´è¿ç§»

---

## ğŸ—“ï¸ è¯¦ç»†å®æ–½æ—¶é—´è¡¨

### Day 1: æ•°æ®åº“æ¶æ„å‡†å¤‡ (ä»Šæ—¥)
**æ—¶é—´å®‰æ’**: 9:00-17:00
**ç›®æ ‡**: å®Œæˆæ•°æ®åº“æ¶æ„æ›´æ–°ï¼Œå‡†å¤‡è¿ç§»ç¯å¢ƒ

#### ä¸Šåˆ (9:00-12:00)
- [ ] å¤‡ä»½ç°æœ‰æ•°æ®åº“
- [ ] æ‰§è¡Œè¡¨ç»“æ„ALTERæ“ä½œ
- [ ] åˆ›å»ºæ–°çš„å…³ç³»è¡¨
- [ ] åˆ›å»ºå…ƒæ•°æ®è¡¨

#### ä¸‹åˆ (13:00-17:00)
- [ ] æ·»åŠ ç´¢å¼•ä¼˜åŒ–
- [ ] éªŒè¯æ¶æ„æ›´æ–°
- [ ] åˆ›å»ºè¿ç§»åŸºç±»
- [ ] å‡†å¤‡æµ‹è¯•ç¯å¢ƒ

### Day 2: æ ¸å¿ƒè¿ç§»ç±»å¼€å‘
**æ—¶é—´å®‰æ’**: 9:00-17:00
**ç›®æ ‡**: å®Œæˆæ ¸å¿ƒè¿ç§»æ¡†æ¶å’Œå·¥å…·ç±»

#### ä¸Šåˆ (9:00-12:00)
- [ ] åˆ›å»ºå¢å¼ºç‰ˆBaseMigrationç±»
- [ ] å®ç°å†…å®¹è§£æå™¨
- [ ] å¼€å‘æ•°æ®éªŒè¯å™¨
- [ ] å®ç°å…³ç³»æ˜ å°„å™¨

#### ä¸‹åˆ (13:00-17:00)
- [ ] å¼€å‘æ€§èƒ½ç›‘æ§å™¨
- [ ] åˆ›å»ºè¿ç§»æŠ¥å‘Šç”Ÿæˆå™¨
- [ ] ç¼–å†™å•å…ƒæµ‹è¯•
- [ ] é›†æˆæµ‹è¯•æ¡†æ¶

### Day 3: å†…å®¹æ•°æ®è¿ç§»å®ç°
**æ—¶é—´å®‰æ’**: 9:00-17:00
**ç›®æ ‡**: å®Œæˆ3ç§å†…å®¹ç±»å‹çš„è¿ç§»å®ç°

#### ä¸Šåˆ (9:00-12:00)
- [ ] å®ç°FAQæ•°æ®è¿ç§»
- [ ] å®ç°How-toæ•°æ®è¿ç§»
- [ ] è¿ç§»æ­¥éª¤æ•°æ®
- [ ] å¤„ç†SEOå…ƒæ•°æ®

#### ä¸‹åˆ (13:00-17:00)
- [ ] å®ç°Caseæ•°æ®è¿ç§»
- [ ] è¿ç§»æ¡ˆä¾‹è¯¦ç»†ä¿¡æ¯
- [ ] å¤„ç†å·¥å…·å…³è”æ•°æ®
- [ ] è¿ç§»æœ¯è¯­å…³è”æ•°æ®

### Day 4: å…³ç³»æ•°æ®å’ŒæœåŠ¡å±‚æ›´æ–°
**æ—¶é—´å®‰æ’**: 9:00-17:00
**ç›®æ ‡**: å®Œæˆå…³ç³»è¿ç§»å’ŒæœåŠ¡å±‚å¢å¼º

#### ä¸Šåˆ (9:00-12:00)
- [ ] è¿ç§»å†…å®¹é—´å…³ç³»
- [ ] è¿ç§»å·¥å…·å…³ç³»
- [ ] è¿ç§»æœ¯è¯­å…³ç³»
- [ ] éªŒè¯å…³ç³»å®Œæ•´æ€§

#### ä¸‹åˆ (13:00-17:00)
- [ ] æ›´æ–°ContentService
- [ ] æ·»åŠ æ–°çš„æŸ¥è¯¢æ–¹æ³•
- [ ] å®ç°ç¼“å­˜ç­–ç•¥
- [ ] æ›´æ–°APIæ¥å£

### Day 5: æµ‹è¯•ã€ä¼˜åŒ–å’Œéƒ¨ç½²
**æ—¶é—´å®‰æ’**: 9:00-17:00
**ç›®æ ‡**: å®Œæ•´æµ‹è¯•å’Œæ€§èƒ½ä¼˜åŒ–

#### ä¸Šåˆ (9:00-12:00)
- [ ] å•å…ƒæµ‹è¯•è¦†ç›–
- [ ] é›†æˆæµ‹è¯•
- [ ] æ€§èƒ½åŸºå‡†æµ‹è¯•
- [ ] æ•°æ®å®Œæ•´æ€§éªŒè¯

#### ä¸‹åˆ (13:00-17:00)
- [ ] æ‰§è¡Œç”Ÿäº§è¿ç§»
- [ ] ç›‘æ§è¿ç§»è¿‡ç¨‹
- [ ] æ€§èƒ½ä¼˜åŒ–è°ƒæ•´
- [ ] æ–‡æ¡£æ›´æ–°

---

## ğŸ”§ æŠ€æœ¯å®æ–½ç»†èŠ‚

### Phase 1: æ•°æ®åº“æ¶æ„æ›´æ–°è„šæœ¬

```sql
-- å¢å¼ºcontent_itemsè¡¨
ALTER TABLE content_items ADD COLUMN IF NOT EXISTS difficulty TEXT;
ALTER TABLE content_items ADD COLUMN IF NOT EXISTS featured BOOLEAN DEFAULT FALSE;
ALTER TABLE content_items ADD COLUMN IF NOT EXISTS priority INTEGER DEFAULT 0;
ALTER TABLE content_items ADD COLUMN IF NOT EXISTS industry TEXT;
ALTER TABLE content_items ADD COLUMN IF NOT EXISTS target_tool TEXT;
ALTER TABLE content_items ADD COLUMN IF NOT EXISTS seo_meta_description TEXT;
ALTER TABLE content_items ADD COLUMN IF NOT EXISTS seo_keywords TEXT;

-- å†…å®¹å…³ç³»è¡¨
CREATE TABLE IF NOT EXISTS content_relationships (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    from_content_id INTEGER NOT NULL,
    to_content_id INTEGER NOT NULL,
    relationship_type TEXT NOT NULL CHECK (relationship_type IN ('similar', 'prerequisite', 'follow_up')),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (from_content_id) REFERENCES content_items(id) ON DELETE CASCADE,
    FOREIGN KEY (to_content_id) REFERENCES content_items(id) ON DELETE CASCADE,
    UNIQUE(from_content_id, to_content_id, relationship_type)
);

-- å·¥å…·å…³ç³»è¡¨
CREATE TABLE IF NOT EXISTS content_tool_relationships (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    content_id INTEGER NOT NULL,
    tool_url TEXT NOT NULL,
    relationship_type TEXT NOT NULL CHECK (relationship_type IN ('target', 'mentioned', 'used')),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (content_id) REFERENCES content_items(id) ON DELETE CASCADE,
    UNIQUE(content_id, tool_url, relationship_type)
);

-- æœ¯è¯­å…³ç³»è¡¨
CREATE TABLE IF NOT EXISTS content_term_relationships (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    content_id INTEGER NOT NULL,
    term_slug TEXT NOT NULL,
    relationship_type TEXT NOT NULL CHECK (relationship_type IN ('explained', 'mentioned', 'related')),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (content_id) REFERENCES content_items(id) ON DELETE CASCADE,
    UNIQUE(content_id, term_slug, relationship_type)
);

-- æ¡ˆä¾‹è¯¦ç»†ä¿¡æ¯è¡¨
CREATE TABLE IF NOT EXISTS case_details (
    content_id INTEGER PRIMARY KEY,
    problem TEXT,
    solution TEXT,
    results JSON, -- JSONæ•°ç»„
    lessons JSON, -- JSONæ•°ç»„
    tools_used JSON, -- JSONæ•°ç»„
    background TEXT,
    challenge TEXT,
    approach JSON, -- JSONå¯¹è±¡
    results_detail JSON, -- JSONå¯¹è±¡
    key_insights JSON, -- JSONæ•°ç»„
    recommendations JSON, -- JSONæ•°ç»„
    FOREIGN KEY (content_id) REFERENCES content_items(id) ON DELETE CASCADE
);

-- SEOå…ƒæ•°æ®è¡¨
CREATE TABLE IF NOT EXISTS seo_metadata (
    content_id INTEGER PRIMARY KEY,
    meta_description TEXT,
    keywords TEXT, -- JSONæ•°ç»„æ ¼å¼
    og_title TEXT,
    og_description TEXT,
    og_image TEXT,
    twitter_card TEXT,
    FOREIGN KEY (content_id) REFERENCES content_items(id) ON DELETE CASCADE
);

-- How-toæ­¥éª¤è¡¨
CREATE TABLE IF NOT EXISTS howto_steps (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    content_id INTEGER NOT NULL,
    step_id TEXT NOT NULL,
    name TEXT NOT NULL,
    description TEXT NOT NULL,
    tip TEXT,
    warning TEXT,
    step_order INTEGER NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (content_id) REFERENCES content_items(id) ON DELETE CASCADE,
    UNIQUE(content_id, step_id)
);
```

### Phase 2: æ€§èƒ½ä¼˜åŒ–ç´¢å¼•

```sql
-- æ–°å¢ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_content_featured ON content_items(featured, priority);
CREATE INDEX IF NOT EXISTS idx_content_difficulty ON content_items(difficulty);
CREATE INDEX IF NOT EXISTS idx_content_industry ON content_items(industry);
CREATE INDEX IF NOT EXISTS idx_content_target_tool ON content_items(target_tool);
CREATE INDEX IF NOT EXISTS idx_content_seo_meta ON content_items(seo_meta_description);

-- å…³ç³»è¡¨ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_content_relationships_from ON content_relationships(from_content_id);
CREATE INDEX IF NOT EXISTS idx_content_relationships_to ON content_relationships(to_content_id);
CREATE INDEX IF NOT EXISTS idx_content_relationships_type ON content_relationships(relationship_type);
CREATE INDEX IF NOT EXISTS idx_content_tool_relationships ON content_tool_relationships(content_id);
CREATE INDEX IF NOT EXISTS idx_content_tool_relationships_type ON content_tool_relationships(relationship_type);
CREATE INDEX IF NOT EXISTS idx_content_term_relationships ON content_term_relationships(content_id);
CREATE INDEX IF NOT EXISTS idx_content_term_relationships_type ON content_term_relationships(relationship_type);

-- æ­¥éª¤è¡¨ç´¢å¼•
CREATE INDEX IF NOT EXISTS idx_howto_steps_content ON howto_steps(content_id);
CREATE INDEX IF NOT EXISTS idx_howto_steps_order ON howto_steps(step_order);
```

### Phase 3: æ ¸å¿ƒè¿ç§»ç±»è®¾è®¡

```typescript
// å¢å¼ºç‰ˆè¿ç§»åŸºç±»
export abstract class EnhancedContentMigration extends BaseMigration {
    protected performanceMonitor: PerformanceMonitor;
    protected relationshipMapper: RelationshipMapper;
    protected contentValidator: ContentValidator;

    constructor() {
        super();
        this.performanceMonitor = new PerformanceMonitor();
        this.relationshipMapper = new RelationshipMapper(this.db);
        this.contentValidator = new ContentValidator();
    }

    protected async migrateWithMonitoring<T>(
        operation: string,
        migrateFn: () => Promise<T>
    ): Promise<T> {
        this.performanceMonitor.start(operation);
        try {
            const result = await migrateFn();
            this.performanceMonitor.end(operation);
            return result;
        } catch (error) {
            this.performanceMonitor.error(operation, error);
            throw error;
        }
    }

    protected async validateAndLog(content: any, type: string): Promise<boolean> {
        const isValid = await this.contentValidator.validate(content, type);
        if (!isValid) {
            console.warn(`Validation failed for ${type} content:`,
                this.contentValidator.getErrors());
        }
        return isValid;
    }
}

// å†…å®¹è§£æå™¨
export class ContentParser {
    static parseFAQ(jsonData: any): FAQItem[] {
        return jsonData.items.map((item: any) => ({
            id: item.id,
            slug: item.slug,
            frontmatter: item.frontmatter,
            question: item.question,
            answer: item.answer,
            relatedQuestions: item.relatedQuestions || []
        }));
    }

    static parseHowTo(jsonData: any): HowToItem {
        return {
            frontmatter: jsonData.frontmatter,
            steps: jsonData.steps || [],
            content: jsonData.content || ''
        };
    }

    static parseCase(jsonData: any): CaseItem {
        return {
            frontmatter: jsonData.frontmatter,
            content: jsonData.content
        };
    }
}

// å…³ç³»æ˜ å°„å™¨
export class RelationshipMapper {
    constructor(private db: Database.Database) {}

    async mapContentRelationships(
        contentId: number,
        relationships: any,
        type: string
    ): Promise<void> {
        if (!relationships) return;

        // æ˜ å°„å·¥å…·å…³ç³»
        if (relationships.tools) {
            await this.mapToolRelationships(contentId, relationships.tools, type);
        }

        // æ˜ å°„æœ¯è¯­å…³ç³»
        if (relationships.glossary) {
            await this.mapTermRelationships(contentId, relationships.glossary, 'related');
        }

        // æ˜ å°„FAQå…³ç³»
        if (relationships.faq) {
            await this.mapContentToContentRelationships(contentId, relationships.faq, 'similar');
        }

        // æ˜ å°„How-toå…³ç³»
        if (relationships.howto) {
            await this.mapContentToContentRelationships(contentId, relationships.howto, 'prerequisite');
        }
    }

    private async mapToolRelationships(
        contentId: number,
        tools: string[],
        relationshipType: string
    ): Promise<void> {
        for (const toolUrl of tools) {
            this.db.prepare(`
                INSERT OR IGNORE INTO content_tool_relationships
                (content_id, tool_url, relationship_type)
                VALUES (?, ?, ?)
            `).run(contentId, toolUrl, relationshipType);
        }
    }

    private async mapTermRelationships(
        contentId: number,
        terms: string[],
        relationshipType: string
    ): Promise<void> {
        for (const termSlug of terms) {
            this.db.prepare(`
                INSERT OR IGNORE INTO content_term_relationships
                (content_id, term_slug, relationship_type)
                VALUES (?, ?, ?)
            `).run(contentId, termSlug, relationshipType);
        }
    }
}
```

### Phase 4: å…·ä½“è¿ç§»å®ç°

```typescript
// FAQæ•°æ®è¿ç§»
export class FAQMigration extends EnhancedContentMigration {
    async migrate(): Promise<MigrationResult> {
        return this.migrateWithMonitoring('FAQ Migration', async () => {
            const faqData = await this.loadFAQData();
            const results: MigrationItemResult[] = [];

            for (const faqItem of faqData) {
                const result = await this.migrateFAQItem(faqItem);
                results.push(result);
            }

            return {
                success: true,
                totalItems: faqData.length,
                migratedItems: results.filter(r => r.success).length,
                errors: results.filter(r => !r.success).map(r => r.error),
                details: results
            };
        });
    }

    private async migrateFAQItem(faqItem: FAQItem): Promise<MigrationItemResult> {
        try {
            // éªŒè¯æ•°æ®
            if (!await this.validateAndLog(faqItem, 'faq')) {
                return { success: false, error: 'Validation failed' };
            }

            // æ’å…¥ä¸»å†…å®¹
            const contentId = await this.insertContentItem(faqItem);

            // è¿ç§»å…³ç³»
            await this.relationshipMapper.mapContentRelationships(
                contentId,
                faqItem.frontmatter.related,
                'faq'
            );

            // è¿ç§»SEOå…ƒæ•°æ®
            await this.migrateSEOMetadata(contentId, faqItem.frontmatter);

            return { success: true, id: contentId };

        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    private async insertContentItem(faqItem: FAQItem): Promise<number> {
        const result = this.db.prepare(`
            INSERT OR REPLACE INTO content_items (
                slug, title, type, summary, content, status,
                category, priority, featured, created_at, updated_at,
                difficulty, reading_time
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `).run(
            faqItem.slug,
            faqItem.frontmatter.title,
            'faq',
            faqItem.frontmatter.summary,
            faqItem.answer,
            faqItem.frontmatter.status || 'published',
            faqItem.frontmatter.category || 'General',
            faqItem.frontmatter.priority || 0,
            faqItem.frontmatter.featured || false,
            faqItem.frontmatter.created || new Date().toISOString(),
            faqItem.frontmatter.updated || new Date().toISOString(),
            null, // FAQæ²¡æœ‰éš¾åº¦
            this.calculateReadingTime(faqItem.answer)
        );

        return result.lastInsertRowid as number;
    }
}

// How-toæ•°æ®è¿ç§»
export class HowToMigration extends EnhancedContentMigration {
    async migrate(): Promise<MigrationResult> {
        return this.migrateWithMonitoring('How-to Migration', async () => {
            const howToFiles = await this.loadHowToFiles();
            const results: MigrationItemResult[] = [];

            for (const [fileName, howToData] of Object.entries(howToFiles)) {
                const result = await this.migrateHowToItem(howToData);
                results.push({ ...result, fileName });
            }

            return {
                success: true,
                totalItems: howToFiles.length,
                migratedItems: results.filter(r => r.success).length,
                errors: results.filter(r => !r.success).map(r => r.error),
                details: results
            };
        });
    }

    private async migrateHowToItem(howToItem: HowToItem): Promise<MigrationItemResult> {
        try {
            if (!await this.validateAndLog(howToItem, 'howto')) {
                return { success: false, error: 'Validation failed' };
            }

            const contentId = await this.insertHowToContent(howToItem);

            // è¿ç§»æ­¥éª¤
            await this.migrateSteps(contentId, howToItem.steps);

            // è¿ç§»å…³ç³»
            await this.relationshipMapper.mapContentRelationships(
                contentId,
                howToItem.frontmatter.related,
                'howto'
            );

            // è¿ç§»mentionså…³ç³»
            if (howToItem.frontmatter.mentions) {
                await this.relationshipMapper.mapContentRelationships(
                    contentId,
                    howToItem.frontmatter.mentions,
                    'mentions'
                );
            }

            // è¿ç§»SEOå…ƒæ•°æ®
            await this.migrateSEOMetadata(contentId, howToItem.frontmatter);

            return { success: true, id: contentId };

        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    private async migrateSteps(contentId: number, steps: any[]): Promise<void> {
        for (let i = 0; i < steps.length; i++) {
            const step = steps[i];
            this.db.prepare(`
                INSERT OR REPLACE INTO howto_steps (
                    content_id, step_id, name, description,
                    tip, warning, step_order
                ) VALUES (?, ?, ?, ?, ?, ?, ?)
            `).run(
                contentId,
                step.id,
                step.name,
                step.description,
                step.tip || null,
                step.warning || null,
                i + 1
            );
        }
    }
}

// Caseæ•°æ®è¿ç§»
export class CaseMigration extends EnhancedContentMigration {
    async migrate(): Promise<MigrationResult> {
        return this.migrateWithMonitoring('Case Migration', async () => {
            const caseData = await this.loadCaseData();
            const result = await this.migrateCaseItem(caseData);

            return {
                success: result.success,
                totalItems: 1,
                migratedItems: result.success ? 1 : 0,
                errors: result.success ? [] : [result.error],
                details: [result]
            };
        });
    }

    private async migrateCaseItem(caseItem: CaseItem): Promise<MigrationItemResult> {
        try {
            if (!await this.validateAndLog(caseItem, 'case')) {
                return { success: false, error: 'Validation failed' };
            }

            const contentId = await this.insertCaseContent(caseItem);

            // è¿ç§»æ¡ˆä¾‹è¯¦ç»†ä¿¡æ¯
            await this.migrateCaseDetails(contentId, caseItem);

            // è¿ç§»å…³ç³»
            await this.relationshipMapper.mapContentRelationships(
                contentId,
                caseItem.frontmatter.related,
                'case'
            );

            // è¿ç§»SEOå…ƒæ•°æ®
            await this.migrateSEOMetadata(contentId, caseItem.frontmatter);

            return { success: true, id: contentId };

        } catch (error) {
            return { success: false, error: error.message };
        }
    }

    private async migrateCaseDetails(contentId: number, caseItem: CaseItem): Promise<void> {
        const frontmatter = caseItem.frontmatter;

        this.db.prepare(`
            INSERT OR REPLACE INTO case_details (
                content_id, problem, solution, results, lessons,
                tools_used, background, challenge, approach,
                results_detail, key_insights, recommendations
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `).run(
            contentId,
            frontmatter.problem || null,
            frontmatter.solution || null,
            JSON.stringify(frontmatter.results || []),
            JSON.stringify(frontmatter.lessons || []),
            JSON.stringify(frontmatter.toolsUsed || []),
            caseItem.content.background || null,
            caseItem.content.challenge || null,
            JSON.stringify(caseItem.content.approach || {}),
            JSON.stringify(caseItem.content.results_detail || {}),
            JSON.stringify(caseItem.content.key_insights || []),
            JSON.stringify(caseItem.content.recommendations || [])
        );
    }
}
```

### Phase 5: æœåŠ¡å±‚å¢å¼º

```typescript
// å¢å¼ºå†…å®¹æœåŠ¡
export class EnhancedContentService extends ContentService {
    // æ–°å¢æ–¹æ³•
    async getContentWithFullDetails(id: number): Promise<ContentWithFullDetails> {
        const cacheKey = `content_full_${id}`;
        return this.queryWithCache(cacheKey, async () => {
            const content = await this.getContentById(id);
            if (!content) throw new Error('Content not found');

            const [relationships, tools, terms, seo] = await Promise.all([
                this.getContentRelationships(id),
                this.getRelatedTools(id),
                this.getRelatedTerms(id),
                this.getSEOMetadata(id)
            ]);

            // æ ¹æ®ç±»å‹è·å–è¯¦ç»†ä¿¡æ¯
            let details: any = {};
            if (content.type === 'howto') {
                details.steps = await this.getHowToSteps(id);
            } else if (content.type === 'case') {
                details.caseDetails = await this.getCaseDetails(id);
            }

            return {
                ...content,
                relationships,
                relatedTools: tools,
                relatedTerms: terms,
                seo,
                details
            };
        }, 30 * 60 * 1000); // 30åˆ†é’Ÿç¼“å­˜
    }

    async getContentRelationships(id: number): Promise<ContentRelationship[]> {
        return this.db.prepare(`
            SELECT cr.*, ci.title as related_title, ci.type as related_type
            FROM content_relationships cr
            JOIN content_items ci ON cr.to_content_id = ci.id
            WHERE cr.from_content_id = ?
            ORDER BY cr.relationship_type, ci.title
        `).all(id);
    }

    async getRelatedTools(id: number): Promise<RelatedTool[]> {
        return this.db.prepare(`
            SELECT tool_url, relationship_type
            FROM content_tool_relationships
            WHERE content_id = ?
            ORDER BY relationship_type, tool_url
        `).all(id);
    }

    async getRelatedTerms(id: number): Promise<RelatedTerm[]> {
        return this.db.prepare(`
            SELECT ctr.term_slug, ctr.relationship_type, t.title as term_title
            FROM content_term_relationships ctr
            LEFT JOIN glossary_terms t ON ctr.term_slug = t.slug
            WHERE ctr.content_id = ?
            ORDER BY ctr.relationship_type, t.title
        `).all(id);
    }

    async searchContentAdvanced(options: AdvancedSearchOptions): Promise<ContentSearchResult> {
        const conditions: string[] = ['ci.status = "published"'];
        const params: any[] = [];

        // é«˜çº§æœç´¢æ¡ä»¶
        if (options.difficulty) {
            conditions.push('ci.difficulty = ?');
            params.push(options.difficulty);
        }

        if (options.industry) {
            conditions.push('ci.industry = ?');
            params.push(options.industry);
        }

        if (options.featured !== undefined) {
            conditions.push('ci.featured = ?');
            params.push(options.featured ? 1 : 0);
        }

        if (options.targetTool) {
            conditions.push('ci.target_tool = ?');
            params.push(options.targetTool);
        }

        if (options.tags && options.tags.length > 0) {
            const tagConditions = options.tags.map(() => 'ci.tags LIKE ?');
            conditions.push(`(${tagConditions.join(' OR ')})`);
            options.tags.forEach(tag => params.push(`%"${tag}"%`));
        }

        const whereClause = conditions.join(' AND ');

        // è·å–æ€»æ•°
        const countQuery = `
            SELECT COUNT(*) as total
            FROM content_items ci
            WHERE ${whereClause}
        `;
        const { total } = this.db.prepare(countQuery).get(...params);

        // è·å–åˆ†é¡µæ•°æ®
        const dataQuery = `
            SELECT ci.*,
                   CASE
                       WHEN ci.type = 'howto' THEN (SELECT COUNT(*) FROM howto_steps hs WHERE hs.content_id = ci.id)
                       ELSE 0
                   END as step_count
            FROM content_items ci
            WHERE ${whereClause}
            ORDER BY ${this.getOrderByClause(options.sortBy, options.sortOrder)}
            LIMIT ? OFFSET ?
        `;

        params.push(options.limit, options.offset);
        const items = this.db.prepare(dataQuery).all(...params);

        return {
            items,
            total,
            page: Math.floor(options.offset / options.limit) + 1,
            pageSize: options.limit,
            hasNext: options.offset + options.limit < total
        };
    }
}
```

### Phase 6: æ•°æ®éªŒè¯å’Œæµ‹è¯•

```typescript
// æ•°æ®éªŒè¯å™¨
export class ContentDataValidator {
    async validateMigrationIntegrity(): Promise<ValidationResult> {
        const results = {
            contentCount: 0,
            relationshipsCount: 0,
            toolRelationshipsCount: 0,
            termRelationshipsCount: 0,
            stepsCount: 0,
            caseDetailsCount: 0,
            seoMetadataCount: 0,
            errors: [] as string[]
        };

        // éªŒè¯å†…å®¹é¡¹
        results.contentCount = this.db.prepare('SELECT COUNT(*) FROM content_items').get().count;

        // éªŒè¯å…³ç³»æ•°æ®
        results.relationshipsCount = this.db.prepare('SELECT COUNT(*) FROM content_relationships').get().count;
        results.toolRelationshipsCount = this.db.prepare('SELECT COUNT(*) FROM content_tool_relationships').get().count;
        results.termRelationshipsCount = this.db.prepare('SELECT COUNT(*) FROM content_term_relationships').get().count;

        // éªŒè¯æ‰©å±•æ•°æ®
        results.stepsCount = this.db.prepare('SELECT COUNT(*) FROM howto_steps').get().count;
        results.caseDetailsCount = this.db.prepare('SELECT COUNT(*) FROM case_details').get().count;
        results.seoMetadataCount = this.db.prepare('SELECT COUNT(*) FROM seo_metadata').get().count;

        // éªŒè¯æ•°æ®å®Œæ•´æ€§
        this.validateContentItems(results);
        this.validateRelationships(results);
        this.validateSEOData(results);

        return results;
    }

    private validateContentItems(results: ValidationResult): void {
        // æ£€æŸ¥å¿…éœ€å­—æ®µ
        const missingRequired = this.db.prepare(`
            SELECT COUNT(*) as count
            FROM content_items
            WHERE slug IS NULL OR title IS NULL OR type IS NULL
        `).get().count;

        if (missingRequired > 0) {
            results.errors.push(`${missingRequired} content items missing required fields`);
        }

        // æ£€æŸ¥slugå”¯ä¸€æ€§
        const duplicateSlugs = this.db.prepare(`
            SELECT slug, COUNT(*) as count
            FROM content_items
            GROUP BY slug
            HAVING COUNT(*) > 1
        `).all();

        if (duplicateSlugs.length > 0) {
            results.errors.push(`Duplicate slugs found: ${duplicateSlugs.map(d => d.slug).join(', ')}`);
        }
    }

    private validateRelationships(results: ValidationResult): void {
        // éªŒè¯å¤–é”®å®Œæ•´æ€§
        const invalidContentRelationships = this.db.prepare(`
            SELECT COUNT(*) as count
            FROM content_relationships cr
            LEFT JOIN content_items ci ON cr.to_content_id = ci.id
            WHERE ci.id IS NULL
        `).get().count;

        if (invalidContentRelationships > 0) {
            results.errors.push(`${invalidContentRelationships} invalid content relationships`);
        }
    }
}

// æ€§èƒ½æµ‹è¯•
export class MigrationPerformanceTester {
    async runPerformanceTests(): Promise<PerformanceReport> {
        const report: PerformanceReport = {
            contentQueryTimes: [],
            relationshipQueryTimes: [],
            searchQueryTimes: [],
            averageResponseTime: 0,
            cacheHitRate: 0
        };

        // æµ‹è¯•å†…å®¹æŸ¥è¯¢æ€§èƒ½
        for (let i = 0; i < 100; i++) {
            const start = Date.now();
            await this.contentService.getContentById(Math.floor(Math.random() * 10) + 1);
            report.contentQueryTimes.push(Date.now() - start);
        }

        // æµ‹è¯•å…³ç³»æŸ¥è¯¢æ€§èƒ½
        for (let i = 0; i < 50; i++) {
            const start = Date.now();
            await this.contentService.getContentRelationships(Math.floor(Math.random() * 10) + 1);
            report.relationshipQueryTimes.push(Date.now() - start);
        }

        // æµ‹è¯•æœç´¢æ€§èƒ½
        for (let i = 0; i < 30; i++) {
            const start = Date.now();
            await this.contentService.searchContent({
                query: 'statistical',
                limit: 10,
                offset: 0
            });
            report.searchQueryTimes.push(Date.now() - start);
        }

        // è®¡ç®—å¹³å‡å“åº”æ—¶é—´
        const allTimes = [
            ...report.contentQueryTimes,
            ...report.relationshipQueryTimes,
            ...report.searchQueryTimes
        ];
        report.averageResponseTime = allTimes.reduce((a, b) => a + b, 0) / allTimes.length;

        return report;
    }
}
```

---

## ğŸ“Š æˆåŠŸæŒ‡æ ‡å’ŒéªŒè¯æ ‡å‡†

### æŠ€æœ¯æŒ‡æ ‡
- **æ•°æ®å®Œæ•´æ€§**: 100% å†…å®¹é¡¹æˆåŠŸè¿ç§»
- **å…³ç³»å®Œæ•´æ€§**: 95%+ å…³ç³»æ˜ å°„æ­£ç¡®
- **æŸ¥è¯¢æ€§èƒ½**: <2ms å“åº”æ—¶é—´
- **ç¼“å­˜å‘½ä¸­ç‡**: >80%
- **é”™è¯¯ç‡**: <0.5%

### ä¸šåŠ¡æŒ‡æ ‡
- **å†…å®¹ä¸°å¯Œåº¦**: SEOå…ƒæ•°æ®è¦†ç›–ç‡ 100%
- **æœç´¢å‡†ç¡®æ€§**: ç›¸å…³æ€§æå‡ 40%+
- **ç”¨æˆ·ä½“éªŒ**: é¡µé¢åŠ è½½æ—¶é—´ <100ms
- **SEOè¡¨ç°**: ç»“æ„åŒ–æ•°æ®å®Œæ•´æ€§ 100%

### æµ‹è¯•è¦†ç›–ç‡
- **å•å…ƒæµ‹è¯•**: >90%
- **é›†æˆæµ‹è¯•**: >80%
- **ç«¯åˆ°ç«¯æµ‹è¯•**: å…³é”®è·¯å¾„ 100%

---

## ğŸš€ éƒ¨ç½²å’Œç›‘æ§è®¡åˆ’

### éƒ¨ç½²ç­–ç•¥
1. **é¢„å‘å¸ƒç¯å¢ƒ**: å®Œæ•´è¿ç§»å’Œæµ‹è¯•
2. **è“ç»¿éƒ¨ç½²**: é›¶åœæœºæ—¶é—´è¿ç§»
3. **å›æ»šæœºåˆ¶**: å¿«é€Ÿæ¢å¤èƒ½åŠ›
4. **ç›‘æ§å‘Šè­¦**: å®æ—¶æ€§èƒ½ç›‘æ§

### ç›‘æ§æŒ‡æ ‡
- **æ•°æ®åº“æ€§èƒ½**: æŸ¥è¯¢å“åº”æ—¶é—´ã€è¿æ¥æ•°ã€ç¼“å­˜å‘½ä¸­ç‡
- **APIæ€§èƒ½**: å“åº”æ—¶é—´ã€é”™è¯¯ç‡ã€ååé‡
- **ç”¨æˆ·ä½“éªŒ**: é¡µé¢åŠ è½½æ—¶é—´ã€äº¤äº’å“åº”æ—¶é—´
- **ä¸šåŠ¡æŒ‡æ ‡**: å†…å®¹è®¿é—®é‡ã€æœç´¢ä½¿ç”¨ç‡ã€ç”¨æˆ·åœç•™æ—¶é—´

---

**æ–‡æ¡£ç‰ˆæœ¬**: 1.0
**åˆ›å»ºæ—¥æœŸ**: 2025-09-13
**é¢„è®¡å·¥æœŸ**: 5å¤©
**æŠ€æœ¯è´Ÿè´£äºº**: å¼€å‘å›¢é˜Ÿ
**ä¼˜å…ˆçº§**: é«˜